## üìö Patr√≥n de dise√±o recomendado para esta lib: Double Using + Persistencia JSON

### ¬øQu√© es el patr√≥n `Double Using`?

El patr√≥n `Double Using` es una forma organizada y eficiente de trabajar con √≠ndices vectoriales cuando quer√©s:

- Cargar e insertar datos r√°pidamente usando un √≠ndice **FLAT**.
- Persistirlos autom√°ticamente como archivo `.json`.
- Cargar esos datos en un √≠ndice **jer√°rquico** (como HNSW o NSW) para realizar b√∫squedas mucho m√°s r√°pidas.
- Nos valemos de este patr√≥n debido a que VictorSDK implementa IDisposable para el manejo de recursos, de lo contrario, simplemente tenes que llamar a sdk.Dispose(); al final de cada indexaci√≥n, b√∫squeda,etc.

### üéØ ¬øPor qu√© JSON y no archivos binarios?

A diferencia de los m√©todos nativos que generan dumps binarios opacos, la persistencia en JSON:

- ‚úÖ Es **legible** y **portable**.
- ‚úÖ Permite **ver el contenido real** (vectores, IDs, tipo de √≠ndice, etc.).
- ‚úÖ Es **m√°s mantenible** para debug, versionado y tests.
- ‚úÖ No te ata a c√≥mo se serializa el √≠ndice en el core en C.

- Esto te da trazabilidad total: sab√©s exactamente qu√© guardaste, cu√°ndo, c√≥mo, y pod√©s restaurarlo sin depender de un formato binario nativo.

---

### üß™ Ejemplo completo del patr√≥n Double Using

```csharp
    [Test]
    public void DoubleUsing_DumpFlat_ThenLoadHNSW()
    {
        ushort dims = 128;
        string finalPath;

        // PRIMER USING: √≠ndice FLAT ‚Üí inserci√≥n r√°pida y persistencia
        using (VictorSDK flat = new(IndexType.FLAT, DistanceMethod.COSINE, dims))
        {
            for (ulong i = 1; i <= 100; i++)
            {
                float[] vector = Enumerable.Repeat((float)i / 100, dims).ToArray();
                flat.Insert(i, vector, dims);
            }

            // Por si quer√©s persistencia en una ruta custom hac√©s esto.
            VictorPersistence.SetBasePath(@"D:\Users\pc\Desktop\Indices");
            // Persistencia autom√°tica en carpeta ./.victor/
             finalPath = VictorPersistence.DumpToPath_snapshot(flat);

            Console.WriteLine($"√çndice FLAT dumpeado a: {flat}");
        }

        // SEGUNDO USING: √≠ndice HNSW ‚Üí carga del dump y b√∫squeda eficiente
        // Paso 2: cargar el snapshot y reinsertar en √≠ndice HNSW 
        var snapshot = VictorPersistence.ReadSnapshot(finalPath);
        Debug.WriteLine($"Snapshot le√≠do: {snapshot}");

        using (VictorSDK hnsw = new(IndexType.HNSW, snapshot.Method, snapshot.Dimensions, HNSWContext.Create()))
        {
            foreach (var entry in snapshot.Vectors) hnsw.Insert(entry.Id, entry.Vector, snapshot.Dimensions);

            float[] query = Enumerable.Repeat(0.33f, dims).ToArray();
            var result = hnsw.Search(query, dims);

            Console.WriteLine($"Resultado: ID = {result.Label}, Distancia = {result.Distance}");
            Assert.DoesNotThrow(() => hnsw.Search(query, dims));
        }
    }
```

## üìÇ Manejo de archivos y persistencia autom√°tica

# Cuando us√°s DumpToAutoPath, el sistema

- Crea una carpeta .victor/ en la ra√≠z del proyecto si no existe.

- Guarda el archivo con nombre √∫nico: "victor_index_YYYYMMDD_HHMMSS_GUID.json"

- Crea autom√°ticamente un .gitignore dentro de .victorindex/ que ignora todo menos el propio .gitignore:

## üß† ¬øCu√°ndo usar este patr√≥n?

- Cuando quer√©s preprocesar datos r√°pidamente con FLAT, pero necesit√°s performance √≥ptima de b√∫squeda con HNSW.

- Cuando est√°s haciendo pruebas y quer√©s guardar snapshots en JSON para comparar.

- Cuando desarroll√°s una app donde necesit√°s guardar y recuperar √≠ndices persistentes entre ejecuciones.

# Esto te asegura que

- No vas a subir dumps por accidente al repo.

- Pod√©s mantener una colecci√≥n local de snapshots para pruebas, debugging, etc.

## ‚öôÔ∏è Persistencia manual (si quer√©s m√°s control)

- Si quer√©s controlar completamente d√≥nde se guarda el archivo:

``` csharp
string customPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "my_index.json");
VictorPersistence.DumpToFile(flat, customPath, dims, IndexType.FLAT, DistanceMethod.COSINE, flat.GetInsertedVectors());
```

- O configurar una ruta base (Recomendado):

```csharp
var CustomPath = VictorPersistence.SetBasePath("C:\\MiProyecto\\VectorDumps");
```

- Despu√©s pod√©s seguir usando DumpToAutoPath(CustomPath ...) y los archivos se guardar√°n ah√≠.

## ¬øQuer√©s ver todos los vectores guardados?

- Solo abr√≠ el archivo .json, vas a ver una estructura como esta:

```json

{
  "Dimensions": 128,
  "IndexType": "FLAT",
  "Method": "COSINE",
  "Vectors": [
    {
      "Id": 1,
      "Vector": [0.01, 0.01, 0.01, ...]
    },
    {
      "Id": 2,
      "Vector": [0.02, 0.02, 0.02, ...]
    }
  ]
}
```
